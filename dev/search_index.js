var documenterSearchIndex = {"docs":
[{"location":"First steps.html#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"APIdevelopers.html#API-for-Developers","page":"API for Developers","title":"API for Developers","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"CurrentModule = AgentModel","category":"page"},{"location":"APIdevelopers.html#Add-parameters","page":"API for Developers","title":"Add parameters","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"parameterAdapt","category":"page"},{"location":"APIdevelopers.html#AgentModel.parameterAdapt","page":"API for Developers","title":"AgentModel.parameterAdapt","text":"function parameterAdapt(agentModel::Model,inLoop,arg;platform::String=\"cpu\",nChange_=false)\n\nFunction that returns the pieces of the final compiling code for the parameters adapted to the corresponding platform:  \n\narrays to declare containg the parameters declared\nfunctions for parameter updates\nexecution lines\n\nParameters:\n\nagentModel : Model structure\ninLoop : Code of the interaction local to be adapted depending on the neighbborhood\narg : Additional arguments required by the functions\nplatform : Platform to be adapted (\"cpu\" or \"gpu\")\nnChange_ : FILL THE GAP\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#Set-neighbourhood","page":"API for Developers","title":"Set neighbourhood","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"All the neighborhood types X share the same structure. They contain always four elements:","category":"page"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"A NeighborhoodX structure that keeps all the required elements in order to define the neighborhood. This structured is created when calling the setNeighborhoodX! and added to the model.\nThe setNeighborhoodX! function that is the high level function for seting a neighborhood. The details are present in the API.\nA neighboursX function that is runned during compilation time and creates the functions that computed to make the neighborhoods.\nA neighboursXAdapt that assigns the inner loop iterator :nnic2_ into the appropiate term depending on the neighborhood type.","category":"page"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"Functions defined in 2 and 4 have always the same inputs and outputs.","category":"page"},{"location":"APIdevelopers.html#Full-connected","page":"API for Developers","title":"Full connected","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"NeighboursFull\nneighboursFull\nneighboursFullAdapt","category":"page"},{"location":"APIdevelopers.html#AgentModel.NeighboursFull","page":"API for Developers","title":"AgentModel.NeighboursFull","text":"struct NeighboursFull <: Neighbours\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#AgentModel.neighboursFull","page":"API for Developers","title":"AgentModel.neighboursFull","text":"function neighboursFull(agentModel::Model;platform=\"cpu\")\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#AgentModel.neighboursFullAdapt","page":"API for Developers","title":"AgentModel.neighboursFullAdapt","text":"function neighboursFullAdapt(entry)\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#By-Adjacecy","page":"API for Developers","title":"By Adjacecy","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"NeighboursAdjacency\nneighboursByAdjacency\nneighboursByAdjacencyAdapt","category":"page"},{"location":"APIdevelopers.html#AgentModel.NeighboursAdjacency","page":"API for Developers","title":"AgentModel.NeighboursAdjacency","text":"struct NeighboursAdjacency <: Neighbours\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#AgentModel.neighboursByAdjacency","page":"API for Developers","title":"AgentModel.neighboursByAdjacency","text":"function neighboursByAdjacency(agentModel::Model;platform=\"cpu\")\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#AgentModel.neighboursByAdjacencyAdapt","page":"API for Developers","title":"AgentModel.neighboursByAdjacencyAdapt","text":"function neighboursByAdjacencyAdapt(entry)\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#By-Grid","page":"API for Developers","title":"By Grid","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"NeighboursGrid\nneighboursByGrid\nneighboursByGridAdapt\nloopNeighbourGridCreation","category":"page"},{"location":"APIdevelopers.html#AgentModel.NeighboursGrid","page":"API for Developers","title":"AgentModel.NeighboursGrid","text":"struct NeighboursGrid <: Neighbours\n\n\n\n\n\n","category":"type"},{"location":"APIdevelopers.html#AgentModel.neighboursByGrid","page":"API for Developers","title":"AgentModel.neighboursByGrid","text":"function neighboursByGrid(agentModel::Model;platform=\"cpu\")\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#AgentModel.neighboursByGridAdapt","page":"API for Developers","title":"AgentModel.neighboursByGridAdapt","text":"function neighboursByGridAdapt(entry)\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#AgentModel.loopNeighbourGridCreation","page":"API for Developers","title":"AgentModel.loopNeighbourGridCreation","text":"function loopNeighbourGridCreation(i,i0,n,x=nothing,pos=\"\")\n\nAuxiliar function for creating nested loops during the grid creation.\n\n\n\n\n\n","category":"function"},{"location":"APIdevelopers.html#Auxiliar","page":"API for Developers","title":"Auxiliar","text":"","category":"section"},{"location":"APIdevelopers.html","page":"API for Developers","title":"API for Developers","text":"subs","category":"page"},{"location":"APIdevelopers.html#AgentModel.subs","page":"API for Developers","title":"AgentModel.subs","text":"function subs(expr,ob,tar)\n\nSubstitute ob expression or symbol by tar expression or symbol into expression expr.\n\n\n\n\n\nfunction subs(expr,ob,tar)\n\nSubstitute ob expression or symbol by tar expression or symbol into expression expr.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Agent-Based-programing-in-Julia","page":"Home","title":"Agent Based programing in Julia","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The AgetnBased.jl package aims to help fast designing and simulation of Agent Based models.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The following dynamical methods can be implemented in the model:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ODEs\nSDEs with Ito prescription","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Additionally, the package incorporates special functions as: ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Division events\nRemoval events\nRandomly selected pairwise interactions","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The created models can run the simulations both in CPU and CUDA GPU thanks to the CUDA.jl. The possibility to run in the simulations in GPU makes it possible to run in a resonable time simulations with a huge number of particles.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Two options to install de package.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pkg.add(\"AgentModel\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"or clone it from the repository. ","category":"page"},{"location":"index.html#Requirements-and-Optional-Modules","page":"Home","title":"Requirements and Optional Modules","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The current version of AgentModel.jl requires the following packages:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Random >= 1.5 Distributions >= 1.6","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and in the case that the simulations want to be performed in CUDA, additionall","category":"page"},{"location":"API.html#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"API.html","page":"API reference","title":"API reference","text":"CurrentModule = AgentModel","category":"page"},{"location":"API.html#Model","page":"API reference","title":"Model","text":"","category":"section"},{"location":"API.html","page":"API reference","title":"API reference","text":"Model","category":"page"},{"location":"API.html#AgentModel.Model","page":"API reference","title":"AgentModel.Model","text":"mutable struct Model\n\nBasic structure which contains the agent based model.\n\nExamples\n\nm = Model(); #Create empty model\n\naddGlobal!(m,:x); #Add a global variable to the model\n# Here there may be many more additions\n\n\n\n\n\n","category":"type"},{"location":"API.html#Add-Parameters","page":"API reference","title":"Add Parameters","text":"","category":"section"},{"location":"API.html","page":"API reference","title":"API reference","text":"addGlobal!\naddLocal!\naddLocalInteraction!\naddVariable!\naddInteraction!","category":"page"},{"location":"API.html#AgentModel.addGlobal!","page":"API reference","title":"AgentModel.addGlobal!","text":"function addGlobal!(agentModel::Model, addvar::Symbol; updates=\"\", randVar = Tuple{Symbol,String}[])\n\nAdd a global variable to the model with optional update rules.\n\nExamples\n\nm = Model();\n\naddGlobal!(m,:x);\n\nm = Model();\nupdate = \"\nx= r #r is a random variable with μ=0. and σ=1.\n\"\n\naddGlobal!(m,:x,updates=update,randVar=[(:r,Normal(0.,1.))]);\n\n\n\n\n\nfunction addGlobal!(agentModel::Model, addvar::Array{Symbol}; updates=\"\", randVar = Tuple{Symbol,String}[])\n\nAdd a set of global variables to the model with optional update rules.\n\nExamples\n\nm = Model();\n\naddGlobal!(m,[:x,:y]);\n\nm = Model();\nupdate = \" #We update x but not y\nx= r\n\"\n\naddGlobal!(m,[:x,:y],updates=update,randVar=[(:r,Normal,0,1)]);\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.addLocal!","page":"API reference","title":"AgentModel.addLocal!","text":"addLocal!(agentModel::Model, addvar::Symbol; updates=\"\", randVar = Tuple{Symbol,String}[])\n\nAdd a local variable to the model with optional update rules.\n\nExamples\n\nm = Model();\n\naddLocal!(m,:x);\n\nm = Model();\nupdate = \"\nx= r #r is a random variable with μ=0. and σ=1.\n\"\n\naddLocal!(m,:x,updates=update,randVar=[(:r,Normal,0.,1.)]);\n\n\n\n\n\naddLocal!(agentModel::Model, addvar::Array{Symbol}; updates=\"\", randVar = Tuple{Symbol,String}[])\n\nAdd a local variable to the model with optional update rules.\n\nExamples\n\nm = Model();\n\naddGlobal!(m,[:x,:y]);\n\nm = Model();\nupdate = \" #We update x but not y\nx= r\n\"\n\naddGlobal!(m,[:x,:y],updates=update,randVar=[(:r,Normal,0,1)]);\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.addLocalInteraction!","page":"API reference","title":"AgentModel.addLocalInteraction!","text":"function addLocalInteraction!(agentModel::Model, addvar::Symbol, addeqs::String; randVar = Tuple{Symbol,String}[])\n\nAdd a local interaction to the model.\n\nExamples\n\nm = Model();\naddLocal!(m,[:x,:y]);\n\n\ninteraction = \"\nd₁ = sqrt((x₁-x₂)^2+(y₁-y₂)^2)\n\"\naddLocalInteraction!(m,:d,interaction);\n\n\n\n\n\nfunction addLocalInteraction!(agentModel::Model, addvar::Symbol, addeqs::String; randVar = Tuple{Symbol,String}[])\n\nAdd a local interaction to the model.\n\nExamples\n\nm = Model();\naddLocal!(m,[:x,:y]);\n\n\ninteraction = \"\nd₁ = sqrt((x₁-x₂)^2+(y₁-y₂)^2)\ndAbs₁ = abs(x₁-x₂)+abs(y₁-y₂)\n\"\naddLocalInteraction!(m,[:d,:dAbs],interaction);\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.addVariable!","page":"API reference","title":"AgentModel.addVariable!","text":"function addVariable!(agentModel::Model, addvar::Symbol, addeqs::String)\n\nAdd a variable described by an Ordinary or Stochastic Differential Equation.\n\nExamples\n\nm = Model();\neq = \"\ndxdt = -x #Exponential decay\n\"\naddVariable!(m,:x,eq);\n\nm = Model();\neq = \"\ndxdt = -x+ξ #Wiener process\n\"\naddVariable!(m,:x,eq);\n\n\n\n\n\nfunction addVariable!(agentModel::Model, addvar::Symbol, addeqs::String)\n\nAdd a variable described by an Ordinary or Stochastic Differential Equations.\n\nExamples\n\nm = Model();\neq = \"\ndxdt = -x #Exponential decay\ndydt = -y + ξ #Wiener process\n\"\naddVariable!(m,[:x,:y],eq);\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.addInteraction!","page":"API reference","title":"AgentModel.addInteraction!","text":"function addInteraction!(agentModel::Model, addvar::Symbol, addeqs::String)\n\nAdd a interaction parameters to the model. Differently to the local interactions, this parameters will be updated inside the integration steps of the differential equations.\n\nExamples\n\nm = Model();\neq = \"\ndxdt = -x+g*ξ #Wiener process with an additional interaction\n\"\naddVariable!(m,:x,eq);\n\ninteraction = \"\ng₁ += 1./sqrt((x₁-x₂)^2+(y₁-y₂)^2) #The difussion will be affected by the presence of other particles around them.\n\"\naddInteraction!(m,:g,interaction);\n\n\n\n\n\nfunction addInteraction!(agentModel::Model, addvar::Symbol, addeqs::String)\n\nAdd a interaction parameters to the model. Differently to the local interactions, this parameters will be updated inside the integration steps of the differential equations.\n\nExamples\n\nm = Model();\neq = \"\ndxdt = -x+g*ξ+p #Wiener process with an additional interaction\n\"\naddVariable!(m,:x,eq);\n\n\ninteraction = \"\ng₁ += 1./sqrt((x₁-x₂)^2+(y₁-y₂)^2) #The difussion will be affected by the presence of other particles around them.\np₁ += 1./(abs(x₁-x₂)+abs(y₁-y₂)) #The difussion will be affected by the presence of other particles around them.\n\"\naddInteraction!(m,[:g,:p],interaction);\n\n\n\n\n\n","category":"function"},{"location":"API.html#Neighborhoods","page":"API reference","title":"Neighborhoods","text":"","category":"section"},{"location":"API.html","page":"API reference","title":"API reference","text":"setNeighborhoodFull!\nsetNeighborhoodAdjacency!\nsetNeighborhoodGrid!","category":"page"},{"location":"API.html#AgentModel.setNeighborhoodFull!","page":"API reference","title":"AgentModel.setNeighborhoodFull!","text":"function setNeighborhoodFull!(agentModel::Model)\n\nFunction that sets the neighborhoodof the model to fully connected. It is the neighborhood by default if no other neighborhood is defined.\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.setNeighborhoodAdjacency!","page":"API reference","title":"AgentModel.setNeighborhoodAdjacency!","text":"function setNeighborhoodAdjacency!(agentModel::Model, condition::String, nMax::Int)\n\nFunction that creates a track of neighbours based depending on a condition.  It also requires an estimation of the maximum amount of neighbours that a particle will have,  the program will crash if during the evolution, the particle finds more than nMax particles fullfilling the condition.\n\nExamples\n\nm = Model()\n\naddLocal!([:x,:y])\n\ncondition= #Euler distance\n\"\nsqrt((x₁-x₂)^2+(y₁-y₂)^2) < 1.\n\"\nsetNeighborhoodAdjacency!(m,condition,nMax=50) #No more than 50 particles will be in the neighborhood at any time\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.setNeighborhoodGrid!","page":"API reference","title":"AgentModel.setNeighborhoodGrid!","text":"function setNeighborhoodGrid!(agentModel::Model, vars::Array{Symbol}, box::Matrix{<:AbstractFloat}, radius::AbstractFloat)\n\nFunction that keeps track of the cells by assotiating them to a grid position. The neighborhood requires that the variables that define the dimensions of the grid are defined, the size of each dimension and the radius of interaction of each particle.\n\nExample\n\nm = Model()\n\naddLocal!([:x,:y])\n\nvars = [:x,:y] #The particles are neighbors depending on the x and y variables.\nbox = [[-1,-1],[1,1]] #The particles are in a square of size 2 around zero.\nradius = 0.5 #The particles interact at most with particles 0.5 far appart from them.\nsetNeighborhoodGrid!(m,vars,box,radius)\n\n\n\n\n\nfunction setNeighborhoodGrid!(agentModel::Model, vars::Array{Symbol}, box::Matrix{<:AbstractFloat}, radius::Array{<:AbstractFloat})\n\nFunction that keeps track of the cells by assotiating them to a grid position with diferent range for each dimension. The neighborhood requires that the variables that define the dimensions of the grid are defined, the size of each dimension and the radius of interaction of each particle.\n\nExample\n\nm = Model()\n\naddLocal!([:x,:y])\n\nvars = [:x,:y] #The particles are neighbors depending on the x and y variables.\nbox = [[-1,-1],[1,1]] #The particles are in a square of size 2 around zero.\nradius = [0.5,1.] #The particles interact assymetrically in both dimensions.\nsetNeighborhoodGrid!(m,vars,box,radius)\n\n\n\n\n\n","category":"function"},{"location":"API.html#Special","page":"API reference","title":"Special","text":"","category":"section"},{"location":"API.html","page":"API reference","title":"API reference","text":"addDivision!\naddPseudopode!","category":"page"},{"location":"API.html#AgentModel.addDivision!","page":"API reference","title":"AgentModel.addDivision!","text":"function addDivision!(agentModel::Model, condition::String, update::String; randVar = Tuple{Symbol,String}[])\n\nFunction that adds a division process of the particles to the model. Cells divide under condition and update the new parameters with update.\n\nExamples\n\nm = Model();\naddLocal!(m,[:g,:tDiv]); #Add two local variables, g and the time of division tDiv\n\ncondition = \n\"\ntDiv < t\n\"\n\nupdate =\n\"\ng₁ = gₚ*r #Asymmetric split of the component between the two daughter particles\ng₁ = tDivₚ+1.\n\ng₂ = gₚ*(1-r)\ng₂ = tDivₚ+1.\n\"\n\naddDivision!(m,condition,update,randVar=[(:r,\"Uniform\",0.,1.)])\n\n\n\n\n\n","category":"function"},{"location":"API.html#AgentModel.addPseudopode!","page":"API reference","title":"AgentModel.addPseudopode!","text":"function addPseudopode!(agentModel::Model, var::Symbol, tVar::Symbol, neighbourCondition::String, force::String, updateChange::String; randVar = Tuple{Symbol,String}[])\n\nAdd a pseudopode force.\n\nExamples\n\nm = Model()\naddLocal!([:x,:y])\n\nneighbourCondition = \n\"\nsqrt((x₁-x₂)^2+(y₁-y₂)^2) < 2.\n\"\nforce = \n\"\nf = sqrt((x₁-x₂)^2+(y₁-y₂)^2)*exp(-sqrt((x₁-x₂)^2+(y₁-y₂)^2))\n\"\nupdateChange = \n\"\ntPseudo = t + σPseudo\n\"\naddPseudopode!(m, :f, :tPseudo, condition, force, updateChange, randVar = [(:σPseudo,\"Uniform\",1.,2.)])\n\n\n\n\n\n","category":"function"}]
}
